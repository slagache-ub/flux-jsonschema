#!/usr/bin/env python3

# Derived from https://github.com/instrumenta/openapi2jsonschema
import yaml
import json
import os
import requests
import argparse
import logging

argparser = argparse.ArgumentParser(prog='openapi2jsonschema', description='Converts CRDs files to json schemas')

argparser.add_argument('files', nargs='+',
                       help='CRD files to process. May be URL or local path.')
argparser.add_argument('-t', '--trust', action='store_true',
                       help='Disable ssl cert validation')
argparser.add_argument('-o', '--output_dir',
                       help='Output folder')

logger = logging.getLogger(__name__)

def additional_properties(data, skip=False):
    "This recreates the behaviour of kubectl at https://github.com/kubernetes/kubernetes/blob/225b9119d6a8f03fcbe3cc3d590c261965d928d0/pkg/kubectl/validation/schema.go#L312"
    if isinstance(data, dict):
        if "properties" in data and not skip:
            if "additionalProperties" not in data:
                data["additionalProperties"] = False
        for _, v in data.items():
            additional_properties(v)
    return data

def replace_int_or_string(data):
    new = {}
    try:
        for k, v in iter(data.items()):
            new_v = v
            if isinstance(v, dict):
                if "format" in v and v["format"] == "int-or-string":
                    new_v = {"oneOf": [{"type": "string"}, {"type": "integer"}]}
                else:
                    new_v = replace_int_or_string(v)
            elif isinstance(v, list):
                new_v = list()
                for x in v:
                    new_v.append(replace_int_or_string(x))
            else:
                new_v = v
            new[k] = new_v
        return new
    except AttributeError:
        return data

def allow_null_optional_fields(data, parent=None, grand_parent=None, key=None):
    new = {}
    try:
        for k, v in iter(data.items()):
            new_v = v
            if isinstance(v, dict):
                new_v = allow_null_optional_fields(v, data, parent, k)
            elif isinstance(v, list):
                new_v = list()
                for x in v:
                    new_v.append(allow_null_optional_fields(x, v, parent, k))
            elif isinstance(v, str):
                is_non_null_type = k == "type" and v != "null"
                has_required_fields = grand_parent and "required" in grand_parent
                if is_non_null_type and not has_required_fields:
                    new_v = [v, "null"]
            new[k] = new_v
        return new
    except AttributeError:
        return data


def append_no_duplicates(obj, key, value):
    """
    Given a dictionary, lookup the given key, if it doesn't exist create a new array.
    Then check if the given value already exists in the array, if it doesn't add it.
    """
    if key not in obj:
        obj[key] = []
    if value not in obj[key]:
        obj[key].append(value)


def write_schema_file(schema, filename, dir=None):
    schemaJSON = ""

    #schema = additional_properties(schema, skip=not os.getenv("DENY_ROOT_ADDITIONAL_PROPERTIES"))
    schema = replace_int_or_string(schema)
    schemaJSON = json.dumps(schema, indent=2)

    # Dealing with user input here..
    filename = os.path.basename(filename)
    with open(f"{dir if dir else ""}/{filename}", "w") as f:
        f.write(schemaJSON)
    logger.info(f"JSON schema written to {filename}")


def construct_value(load, node):
    # Handle nodes that start with '='
    # See https://github.com/yaml/pyyaml/issues/89
    if not isinstance(node, yaml.ScalarNode):
        raise yaml.constructor.ConstructorError(
            "while constructing a value",
            node.start_mark,
            "expected a scalar, but found %s" % node.id, node.start_mark
        )
    yield str(node.value)

def build_conditional_json(version, kind, filename, dir=None):
    return {
        "if": {
            "properties": {
                "apiVersion": { "pattern": f"^.*{version}$" },
                "kind": { "const": f"{kind}" }
            }
        },
        "then": {
            "$ref": f"https://git-dsi.u-bordeaux.fr/app-ci/flux-jsonschema/-/raw/master/{dir if dir else ""}/{filename}"
        }
    }


if __name__ == "__main__":
    args = argparser.parse_args()
    if args.trust:
        import ssl
        ssl._create_default_https_context = ssl._create_unverified_context
    if args.output_dir:
        os.makedirs(args.output_dir, exist_ok=True)

    yaml.SafeLoader.add_constructor(u'tag:yaml.org,2002:value', construct_value)
    all_json = { "allOf": [] }
    for crdFile in args.files:
        if crdFile.startswith("http"):
            r = requests.get(crdFile)
            if r.status_code == 200:
                crdString = r.text
            else:
                logger.error(f"Status code {r.status_code} while requesting url {crdFile}")
                continue
        else:
            with open(crdFile, "r") as f:
                crdString = f.read()
        crdIterator = yaml.load_all(crdString, Loader=yaml.SafeLoader)
        defs = []
        for y in crdIterator:
            if y is None:
                logger.error("Crd is None")
                continue
            if "items" in y:
                defs.extend(y["items"])
            if "kind" not in y:
                logger.error("Yaml is not a k8s resource")
                continue
            if y["kind"] != "CustomResourceDefinition":
                logger.error("Yaml is not a CRD")
                continue
            else:
                defs.append(y)

        for y in defs:
            filename_format = os.getenv("FILENAME_FORMAT", "{kind}_{version}")
            filename = ""
            if "spec" in y and "versions" in y["spec"] and y["spec"]["versions"]:
                for version in y["spec"]["versions"]:
                    if "schema" in version and "openAPIV3Schema" in version["schema"]:
                        filename = filename_format.format(
                            kind=y["spec"]["names"]["kind"],
                            group=y["spec"]["group"].split(".")[0],
                            fullgroup=y["spec"]["group"],
                            version=version["name"],
                        ).lower() + ".json"

                        schema = version["schema"]["openAPIV3Schema"]
                        write_schema_file(schema, filename, dir=args.output_dir)
                    elif "validation" in y["spec"] and "openAPIV3Schema" in y["spec"]["validation"]:
                        filename = filename_format.format(
                            kind=y["spec"]["names"]["kind"],
                            group=y["spec"]["group"].split(".")[0],
                            fullgroup=y["spec"]["group"],
                            version=version["name"],
                        ).lower() + ".json"

                        schema = y["spec"]["validation"]["openAPIV3Schema"]
                        write_schema_file(schema, filename, dir=args.output_dir)
                    all_json["allOf"].append(build_conditional_json(
                        version=version["name"],
                        kind=y["spec"]["names"]["kind"],
                        filename=filename,
                        dir=args.output_dir
                    ))
            elif "spec" in y and "validation" in y["spec"] and "openAPIV3Schema" in y["spec"]["validation"]:
                filename = filename_format.format(
                    kind=y["spec"]["names"]["kind"],
                    group=y["spec"]["group"].split(".")[0],
                    fullgroup=y["spec"]["group"],
                    version=y["spec"]["version"],
                ).lower() + ".json"

                schema = y["spec"]["validation"]["openAPIV3Schema"]
                write_schema_file(schema, filename, dir=args.output_dir)
                all_json["allOf"].append(build_conditional_json(
                        version=y["spec"]["version"],
                        kind=y["spec"]["names"]["kind"],
                        filename=filename,
                        dir=args.output_dir
                    ))
    with open(f"{args.output_dir if args.output_dir else ""}/all.json", "w+") as f:
        json.dump(all_json, f, indent=2)